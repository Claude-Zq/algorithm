# 第四章

## 例题

### 例题4-1

#### 题目

给定两个长度相同且不超过100的字符串，判断是否能把其中一个字符串的各个字母重排，然后对26个字母做一个一一映射，使得两个字符串相同。
例如，JWPUDJSTVP重排后可以得到WJDUPSJPVT，然后把每个字母映射到它前一个字母（B->A,V->B,…,Z->Y,A->Z），得到VICTORIOUS。输出两个字符串，输出YES或者NO。

Sample Input
JWPUDJSTVP
VICTORIOUS
Sample Output
YES
Source
Northeastern Europe 2004

#### 代码

注意：输入文件每行均以\n结尾，否则运行结果有问题

```c
#include <stdio.h>
#include<string.h>
#include<stdlib.h>
#define maxn 105

/*降序排列谓词*/
int cmp(const void *a,const void *b){
    return  *(int*)b-*(int*)a;
}

/*记录长度为n字符串s中各个字母出现的次数*/
void Record(char *s,int n,int *cnt)
{
    for(int i = 0;i<n;i++) cnt[s[i]-'A']++;
}

int main()
{
    FILE *fin = fopen("input.txt","r");
    FILE *fout = fopen("output.txt","w");
    char s[maxn];
    int cnt1[26]= {0},cnt2[26] = {0};

    //输入第一个字符串
    fgets(s,maxn,fin);
    Record(s,strlen(s)-1,cnt1); /*统计*/
    qsort(cnt1,sizeof(cnt1)/sizeof(int),sizeof(int),cmp);/*排序*/

    //输入第二个字符串
    fgets(s,maxn,fin);
    Record(s,strlen(s)-1,cnt2); /*统计*/
    qsort(cnt2,sizeof(cnt2)/sizeof(int),sizeof(int),cmp);/*排序*/

    int ok = 1;
    for (int i = 0;i < 26;i++){
        if(cnt1[i]!=cnt2[i]){ok = 0;break;}
        if(cnt1[i]==0||cnt2==0)break;
    }

    if(ok) fprintf(fout,"YES\n");
    else fprintf(fout,"NO\n");

    fclose(fin);
    fclose(fout);
    return 0;
}

```



### 例4-2

#### 题目

刽子手游戏其实是一款猜单词游戏，如图4- 1所示。游戏规则是这样的：计算机想一个单词 让你猜，你每次可以猜一个字母。如果单词里有那个字母，所有该字母会显示出来；如果没有那 个字母，则计算机会在一幅“刽子手”画上填一 笔。这幅画一共需要7笔就能完成，因此你最多 只能错6次。注意，猜一个已经猜过的字母也算错。在本题中，你的任务是编写一个“裁判”程序，输入单词和玩家的猜测，判断玩家赢了 （You win.）、输了（You lose.）还是放弃了 （You chickened out.）。每组数据包含3行，第1 行是游戏编号（-1为输入结束标记），第2行是 计算机想的单词，第3行是玩家的猜测。后两行 保证只含小写字母。
测试样例：
1cheese chese
2cheese abcdefg
3cheese abcdefgij
1样例输出:
Round 1 You win.
Round 2 You chickened out.
Round 3 You lose.


#### 代码



```c
#include <stdio.h>
#include<string.h>


/*统计长为n的字符串s各个字母的个数于数组N中*/
void CountAlpha(char *s,int n,int *N){
    for (int i = 0;i < n;i++) N[s[i]-'a']++;
}


int main()
{
    FILE *fin = fopen("input.txt","r");
    FILE *fout = fopen("output.txt","w");

    int T,kcase = 0;
    int ANS[26],GUS[26];
    char s[50];
    const char* msg[] = {"You win.","You lose.","You chickened out."};
    while(fscanf(fin,"%d",&T)==1&&T!=-1)
    {
        /*清一下*/
        memset(ANS,0,sizeof(ANS));
        memset(GUS,0,sizeof(GUS));
        /*输入答案字符串*/
        fscanf(fin,"%s",s);
        CountAlpha(s,strlen(s),ANS);/*统计*/

        /*输入玩家猜的字符串*/
        fscanf(fin,"%s",s);
        CountAlpha(s,strlen(s),GUS);/*统计*/

        int ans = 0;/*默认玩家猜对*/
        int error = 0;/*猜错次数*/
        for(int i = 0;i < 26;i++){
            /*猜错*/
            if(!ANS[i]&&GUS[i]){error += GUS[i];}
            /*猜漏*/
            else if(ANS[i]&&!GUS[i]) ans = 2;
            /*猜对*/
            else if(ANS[i]&&GUS[i]) {if(GUS[i]>1) error += GUS[i] - 1;/*猜重复*/}
            /*猜错7次*/
            if(error >= 7) {ans = 1;break;}
        }
		/*输出结果*/
        fprintf(fout,"Round %d\n%s\n",++kcase,msg[ans]);
    }

    fclose(fin);
    fclose(fout);

    return 0;
}

```

### 例题4-3

#### 题目

n(n<20)个人站成一圈，逆时针编号为1～n。有两个官员，A从1开始逆时针数，B从n开始顺时针数。在每一轮中，官员A数k个就停下来，官员B数m个就停下来（注意有可能两个官员停在同一个人上）。接下来被官员选中的人（1个或者2个）离开队伍。

输入n，k，m输出每轮里被选中的人的编号（如果有两个人，先输出被A选中的）。例如，n=10，k=4，m=3，输出为4 8, 9 5, 3 1, 2 6, 10, 7。注意：输出的每个数应当恰好占3列。

输入： 
10 4 3

输出： 
_ _ 4_ _ 8,_ _ 9_ _ 5,_ _ 3_ _ 1,_ _ 2_ _ 6,_ 10,_ _ 7



#### 代码

```c
#include <stdio.h>
#include<string.h>
#define maxn 20

int main()
{
    FILE *fin = fopen("input.txt","r");
    FILE *fout = fopen("output.txt","w");
    
    int Q[maxn];
    int n,k,m;

    while(fscanf(fin,"%d%d%d",&n,&k,&m)==3&&n>0)
    {
        int left = n;
        memset(Q,-1,sizeof(Q)); /*-1表示人未被带走*/
        /*A、B在数组的位置*/
        int iA = n-1,iB = 0;

        while(left>0) /*每人时退出*/
        {
            //A移动
            for(int i = k;i>0;){iA = (iA+1)%n;if(Q[iA])i--;}
            //B移动
            for(int i = m;i>0;){if(--iB < 0) iB+=n; if(Q[iB])i--;}

            /*带走人*/
            if(iA == iB)
            {
                fprintf(fout,"%3d",iA+1);
                Q[iA] = 0;
                left--;
            }
            else
            {
                fprintf(fout,"%3d%3d",iA+1,iB+1);
                Q[iA] = Q[iB] = 0;
                left -= 2;
            }
            if(left) fprintf(fout,",");
        }
        fputc('\n',fout);
    }

    fclose(fin);
    fclose(fout);

    return 0;
}

```





## 习题

