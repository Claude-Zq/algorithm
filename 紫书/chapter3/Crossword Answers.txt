## 习题3-1

### 题目

给出一个由O和X组成的串（ 长度为1～ 80） ， 统计得分。 每个O的得分为目前连续出现
的O的个数， X的得分为0。 例如， OOXXOXXOOO的得分为1+2+0+0+1+0+0+1+2+3。

### 代码

```d
#include <stdio.h>
#include <string.h>

int main()
{
    char s[100];
    int score = 0,count = 0;

    scanf("%s",s);
    int n = strlen(s);
    for(int i = 0;i < n;i++)
    {
        if (s[i]=='O')  score += (++count);
        else count = 0;
    }
    printf("%d",score);
    return 0;
}

```



## 习题3-2

### 题目

分子量（Molar Mass, ACM/ICPC Seoul 2007, UVa1586）
给出一种物质的分子式（不带括号），求分子量。本题中的分子式只包含4种原子，分别为C,H,O,N，原子量分别为12.01，1.008，16.00，14.01（单位：g/mol）。例如，C6H5OH的分子量为94.108g/mol。

Sample Input
4
C
C6H5OH
NH2CH2COOH
C12H22O11

Sample Output
12.010
94.108
75.070
342.296

### 代码

```c
#include <stdio.h>
#include <ctype.h>


int main()
{
    char s[50];
    int T;
    scanf("%d",&T);

    while(T--)
    {
        char *p = s;
        double ans = 0;
        scanf("%s",s);
        while(*(p+1)!='\0') p++;
        while(p>=s)
        {
            int n = 1;
            if(isdigit(*p))
            {
                n=*p-'0';
                p--;
                /*角标时两位数*/
                if(isdigit(*p))
                {
                    n += (*p-'0')*10;
                    p--;
                }
            }
            switch (*p)
            {
                case 'H': ans += 1.008 * n;break;
                case 'C': ans += 12.01 * n;break;
                case 'O': ans += 16.00 * n;break;
                case 'N': ans += 14.01 * n;break;
            }
            p--;
        }
        printf("%.3f%c",ans,(T? '\n':'\0'));
    }

    return 0;
}

```



## 习题3-3

### 题目

把前n（n≤10000）个整数顺次写在一起：123456789101112…数一数0～9各出现多少次（输出10个整数，分别是0，1，…，9出现的次数）。

样例输入

2

3

13

样例输出

0 1 1 1 0 0 0 0 0 0

1 6 2 2 1 1 1 1 1 1





### 代码

```c
#include <stdio.h>

int main()
{
    int T;
    scanf("%d",&T);

    while(T--)
    {
        int ans[10] = {0};

        int n;
        scanf("%d",&n);
        for (int i = 1;i <= n;i++)
        {
            int j = i;
            while (j != 0){ans[j%10]++;j /= 10;}

        }

        for (int i = 0;i < 10;i++)
        {
            if(i) putchar(' ');
            printf("%d",ans[i]);
        }
        if(T) putchar('\n'); /*结尾无空行*/

    }

    return 0;
}

```

## 习题3-4

### 题目

**习题3-4 周期串（Periodic Strings, UVa455）**
如果一个字符串可以由某个长度为k的字符串重复多次得到，则称该串以k为周期。 例如，abcabcabcabc以3为周期（注意，它也以6和12为周期）。输入一个长度不超过80的字符串，输出其最小周期。



### 代码

```c
#include <stdio.h>
#include <string.h>

/*函数功能：判断T是不是长度是len的字符串周期*/
//将len放在参数列表而不是在函数体中，防止拖慢速度
int JudgeT(char s[],int len,int T)
{
    if (len % T != 0) return 0; /*如果长度不是周期的整数倍*/
    for (int i = T;i < len;i++) if(s[i%T]!= s[i]) return 0;
    return 1;
}

int main()
{
    int n;
    scanf("%d",&n);

    while(n--)
    {
       char s[100];
       scanf("%s",s);
       int len = strlen(s);
       for (int T = 1;T <=len;T++)
       {
           if (JudgeT(s,len,T)){printf("%d\n",T);break;}
       }
    }
    return 0;
}

```

## 习题3-5

### 题目

一个5*5的网格中恰好有一个格子是空的，其他格子各有一个字母，四条指令A,B,L,R分别表示将空格上、下、左、右移动。输入初始网格和一串指令（以0结束），输出执行操作后的网格。越界则输出“This puzzle has no final configuration.”。



### 代码

```d
#include <stdio.h>
#include <string.h>

/*找到谜题的空格*/
void FindSpace(int *i,int *j,char s[][7])
{
    for (*i = 0;*i < 5;(*i)++)
        for (*j = 0; *j < 5;(*j)++) if(s[*i][*j] == ' ' ||s[*i][*j]=='\n') return;
}

/*判断对s[][]的位置ij空格的操作op是否合法*/
//若合法：完成操作并更新i,j
//若不合法：返回零
int Operate(char s[][7],int *i,int *j,char op)
{
    switch (op)
    {
        case 'A':
            {
                if(*i==0) return 0;
                s[*i][*j] = s[(*i)-1][*j];
                s[(*i)-1][*j] = ' ';
                (*i)--;/*更新空格位置*/
                break;
            }
        case 'B':
            {
                if(*i==4) return 0;
                s[*i][*j] = s[(*i)+1][*j];
                s[(*i)+1][*j] = ' ';
                (*i)++;/*更新空格位置*/
                break;
            }
        case 'L':
            {
                if(*j==0) return 0;
                s[*i][*j] = s[*i][(*j)-1];
                s[*i][(*j)-1] = ' ';
                (*j)--;/*更新空格位置*/
                break;
            }
        case 'R':
            {
                if(*j==4) return 0;
                s[*i][*j] = s[*i][(*j)+1];
                s[*i][(*j)+1] = ' ';
                (*j)++;/*更新空格位置*/
                break;
            }

        default: return 0;
    }
    /*成功操作*/
   return 1;
}

int main()
{
   	FILE *fin = fopen("input.txt","r");
    FILE *fout = fopen("output.txt","w");
    char s[5][7];


    //录入谜题
    for (int i = 0;i<5;i++)
    {
        fgets(s[i],7,fin);
        fgetc(fin); /*后面还有回车,需要读走*/
    }

    //输入指令
    char op[50];
    fscanf(fin,"%s",op);

     //找到空格
    int ispace,jspace;
    FindSpace(&ispace,&jspace,s);

    int ok = 1;/*是否有结果*/
    for (int i = 0;op[i] != '0'&&op[i]!='\0';i++) /*遇到0或者空字符结束*/
        if (!Operate(s,&ispace,&jspace,op[i])){ok = 0;break;}

    //打印结果
    fputc('\n',fout);
    if(ok) for (int i = 0;i<5;i++) fprintf(fout,"%s",s[i]);
    else fprintf(fout,"This puzzle has no final configuration\n");

    fclose(fin);
    fclose(fout);
    return 0;
}

```

## 习题3-6

### 题目

题目：输入一个 r 行 c 列的网格，黑格用“*”表示，每个白格都填有一个字母。如果一个白格的左边相邻位置或者上面相邻位置没有白格（可能是黑格，也可能出了网格边界），则称这个白格是一个起始格。
首先把所有起始格按照从上到下、从左到右的顺序编号为 1,2,3,… ,如图所示。
接下来要找出所有的横向单词（Across）。这些单词必须从一个起始格开始，向右延伸到一个黑格的左边或者整个网格的最右列。
最后找出所有的竖向单词（Down）。这些单词必须从一个起始格开始，向下延伸到一个黑格的上边或者整个网格的最下行。

```c
Sample Input
2 2
AT
*O
6 7
AIM*DEN
*ME*ONE
UPON*TO
SO*ERIN
*SA*OR*
IES*DEA
0

Sample Output
puzzle #1:
Across
1.AT
3.O
Down
1.A
2.TO
puzzle #2:
Across
1.AIM
4.DEN
7.ME
8.ONE
9.UPON
11.TO
12.SO
13.ERIN
15.SA
17.OR
18.IES
19.DEA
Down
1.A
2.IMPOSE
3.MEO
4.DO
5.ENTIRE
6.NEON
9.US
10.NE
14.ROD
16.AS
18.I
20.A

```





```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    FILE *fin = fopen("input.txt","r");
    FILE *fout = fopen("output.txt","w");

    int r,c,kcase = 0;
    while(fscanf(fin,"%d%d",&r,&c)==2)
    {
        if(r==0&&c==0) break;
        /*在堆区创建一个二维字符数组*/
        char** S = (char**)malloc(r*sizeof(char*));
        for (int i = 0;i < r;i++)
        {
            S[i] = (char *) malloc((c+2)*sizeof(char));
        }
         /*在堆区创建一个二维整形数组*/
        int** N = (int**)malloc(r*sizeof(int*));
        for (int i = 0;i < r;i++)
        {
            N[i] = (int*) malloc((c)*sizeof(int));
        }

        /*输入字符格子*/
        fgetc(fin); /*消掉回车*/
        for (int i = 0;i<r;i++) fgets(S[i],c+2,fin); /*必须保证输入样例每行最后没有空格*/


        /*将字符格子转为数字格子*/
        int num = 0;
        for(int i = 0;i <r;i++)
        {
            for (int j = 0;j < c;j++)
            {
                if(S[i][j] == '*') N[i][j] = 0; /*黑格子*/
                else
                {
                   if (!i||!j||S[i][j-1]=='*'||S[i-1][j]=='*') N[i][j] =++num;/*起始白格*/                    					 else N[i][j] = -1; /*普通白格子*/
                }
            }
        }

        fprintf(fout,"puzzle #%d:\n",++kcase);

        //打印横向单词
        fprintf(fout,"Across\n");
        for (int i = 0;i < r;i++)
        {
            for (int j = 0; j < c;j++)
            {
                if(N[i][j])
                {
                    fprintf(fout,"%d.",N[i][j]);
                    while(j<c&&N[i][j]) fprintf(fout,"%c",S[i][j++]);
                    fprintf(fout,"\n");
                }
            }
        }

        //打印纵向单词
        fprintf(fout,"Down\n");
        for (int i =0;i < r;i++)
            for (int j = 0;j < c;j++)
                if(N[i][j])
                {
                    fprintf(fout,"%d.",N[i][j]);
                    int k = i;
                    while(k<r&&N[k][j]){fprintf(fout,"%c",S[k][j]);N[k++][j]=0;}
                    fprintf(fout,"\n");
                }


        /*释放字符数组*/
        for (int i = 0;i < r;i++)
        {
            free(S[i]);
        }
        free(S);
         /*释放整形数组*/
        for (int i = 0;i < r;i++)
        {
            free(N[i]);
        }
        free(N);
    }

    fclose(fin);
    fclose(fout);
    return 0;
}



```

