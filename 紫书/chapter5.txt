# chapter 5

## Where is the Marble?

### Q

现有N个大理石，每个大理石上写了一个非负整数、首先把各数从小到大排序；然后回答Q个问题。每个问题问是否有一个大理石写着某个整数x，如果是，还要回答哪个大理石上写着x。排序后的大理石从左到右编号为1~N。
(在样例中，为了节约篇幅，所有大理石的数合并到一行，所有问题也合并到一行。)

**样例输入：**
4 1
2 3 5 1
5
5 2
1 3 3 3 1
2 3

**样例输出：**
CASE# 1：
5 found at 4
CASE# 2：
2 not found

3 found at 3 



### A A1

```c
#pragma warning(disable:4996)/*解决fopen、fscanf 在VS中要求替换为fopen_s、fscanf_s*/
#include<vector>
#include<algorithm>
#include <cstdio>
using namespace std;

int main()
{
	FILE* fin = fopen("input.txt", "r");
	FILE* fout = fopen("output.txt", "w");

	int N, Q;
	int kcase = 0;
	while (fscanf(fin,"%d %d",&N,&Q)==2) {
		vector<int> M;
		/*输入大理石上的数字*/
		for (int i = 0; i < N; i++)
		{
			int digit;
			fscanf(fin,"%d", &digit);
			M.push_back(digit);
		}
		/*升序排列*/
		sort(M.begin(), M.end());
		/*输入问题*/
		fprintf(fout, "CASE# %d:\n", ++kcase);
		for (int i = 0; i < Q; i++) {
			int q;
			fscanf(fin, "%d", &q);
			vector<int>::iterator pos = find(M.begin(), M.end(), q);
            /*输出答案*/
			if (pos == M.end()) fprintf(fout, "%d not found\n", q);/*没找到*/
			else fprintf(fout, "%d found at %d\n", q, (int)(pos - M.begin()) + 1);/*找到了*/
		}
	
	}

	fclose(fin);
	fclose(fout);
	return 0;
}
```

## The Blocks Problem

### Q

输入n，得到编号为0~n-1的木块，分别摆放在顺序排列编号为0~n-1的位置。现对这些木块进行操作，操作分为四种。

1、move a onto b：把木块a、b上的木块放回各自的原位，再把a放到b上；

2、move a over b：把a上的木块放回各自的原位，再把a发到含b的堆上；

3、pile a onto b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；

4、pile a over b：把a连同a上木块移到含b的堆上。

当输入quit时，结束操作并输出0~n-1的位置上的木块情况

Sample Input 
10
move 9 onto 1
move 8 over 1
move 7 over 1
move 6 over 1
pile 8 over 6
pile 8 over 5
move 2 over 1
move 4 over 9
quit
Sample Output 
 0: 0
 1: 1 9 2 4
 2:
 3: 3
 4:
 5: 5 8 7 6
 6:
 7:
 8:
 9:

### A A3

#### version 1

```c++
#pragma warning(disable:4996)/*解决fopen、fscanf 在VS中要求替换为fopen_s、fscanf_s*/
#include<vector>
#include <cstdio>
using namespace std;


/*找出木块a在Wood中的行数*/
int get_i(vector<vector<int>>& Wood, int a){
	return Wood[a][0] == -1 ? Wood[a][1] : Wood[a][0];
}
/*找出木块a在Wood中的列数*/
int get_j(vector<vector<int>>& Wood, int a){
	int i = get_i(Wood, a);
	for (int j = 0; j < Wood[i].size(); j++) { if (Wood[i][j] == a) return j; }
	return -1;
}

/*将木块a上方的木块归位*/
void reset_above(vector<vector<int>>& Wood, int a){
	int i = get_i(Wood, a);
	int j = get_j(Wood, a);
	for (int k = Wood[i].size()-1; k > j; k--) {
		Wood[Wood[i][k]][0] = Wood[i][k];
		Wood[Wood[i][k]].pop_back();
		Wood[i].pop_back();
	}
}

/*操作move a onto b*/
void MN(vector<vector<int>>& Wood, int a, int b)
{
	/*把a、b上方的木块归位*/
	reset_above(Wood, a);
	reset_above(Wood, b);
	int ia = get_i(Wood, a);
	int ib = get_i(Wood, b);
	Wood[ib].push_back(a); /*把a放到b上*/
	Wood[ia].pop_back();
	if (Wood[ia].size() == 0) { Wood[ia].push_back(-1); Wood[ia].push_back(ib); }/*如果a在原位*/
}

/*操作move a over b*/
void MV(vector<vector<int>>& Wood, int a, int b)
{
	reset_above(Wood, a);
	int ia = get_i(Wood, a);
	int ib = get_i(Wood, b);

	Wood[ib].push_back(a);
	Wood[ia].pop_back();
	if (Wood[ia].size() == 0) { Wood[ia].push_back(-1); Wood[ia].push_back(ib); }/*如果a在原位*/
}

/*操作pile a onto b*/
void PN(vector<vector<int>>& Wood, int a, int b)
{
	reset_above(Wood, b);
	int ib = get_i(Wood, b);
	int ia = get_i(Wood, a), ja = get_j(Wood, a);
	for (int j = ja; j < Wood[ia].size(); j++) Wood[ib].push_back(Wood[ia][j]); /*移到b上*/
	for (int j = Wood[ia].size() - 1; j >= ja; j--)Wood[ia].pop_back(); /*擦掉原位*/
	if (Wood[ia].size() == 0) { Wood[ia].push_back(-1); Wood[ia].push_back(ib); }
}

/*操作pile a over b*/
void PV(vector<vector<int>>& Wood, int a, int b)
{
	int ib = get_i(Wood, b);
	int ia = get_i(Wood, a), ja = get_j(Wood, a);
	for (int j = ja; j < Wood[ia].size(); j++) Wood[ib].push_back(Wood[ia][j]); /*移到b上*/
	for (int j = Wood[ia].size() - 1; j >= ja; j--)Wood[ia].pop_back(); /*擦掉原位*/
	if (Wood[ia].size() == 0) { Wood[ia].push_back(-1); Wood[ia].push_back(ib); }
}


int main()
{
    FILE* fin = fopen("input.txt", "r");
	FILE* fout = fopen("output.txt", "w");

	int n;
	fscanf(fin, "%d", &n);

	vector<vector<int>> Wood;
	Wood.resize(n);
	/*初始化放木块的vector*/
	for (int i = 0; i < n; i++) Wood[i].push_back(i);
    
	char s1[10], s2[10];
	int a, b;

	/*执行操作*/
	while (fscanf(fin, "%s %d %s %d", s1, &a, s2, &b) == 4)
	{
		if (get_i(Wood, a) == get_i(Wood, b)) continue; /*如果a,b在同一堆*/
		if (s1[0] == 'm' && s2[1] == 'n') MN(Wood, a, b);
		else if(s1[0] == 'm' && s2[1] == 'v') MV(Wood, a, b);
		else if(s1[0] == 'p' && s2[1] == 'n') PN(Wood, a, b);
		else if(s1[0] == 'p' && s2[1] == 'v') PV(Wood, a, b);
	}
	/*输出结果*/
	for (int i = 0; i < n; i++){
		fprintf(fout, "%d:", i);
		if (Wood[i][0] != -1) {
			for (int j = 0; j < Wood[i].size(); j++) {
				if (j) fprintf(fout, " ");
				fprintf(fout, "%d", Wood[i][j]);
			}
		}
		fputc('\n', fout);
	}


	fclose(fin);
	fclose(fout);
	return 0;
}
```

#### version 2

##### 改进：

1.将Wood声明为全局变量，避免多次传参，较少代码量

2.提取出四种操作的共同点，减少重复代码

##### 优点：

找木块的速度有提升：

原作：横标:O(n),纵标:O(n)

我的：横标O(1),纵坐标: O(n)

方法：木块a如果不在原位，则原位Wood[a]必定为空，所以原位的第一位插-1来表示木块不在，第二位记录其所在堆数的横标。另外，要找到纵标时，也可直接跳到对应堆，故速度也有所提升

```c++
#pragma warning(disable:4996)/*解决fopen、fscanf 在VS中要求替换为fopen_s、fscanf_s*/
#include<vector>
#include <cstdio>
using namespace std;
vector<vector<int>> Wood;


/*找出木块a在Wood中的行数*/
int get_i(int a) {
	return Wood[a][0] == -1 ? Wood[a][1] : Wood[a][0];
}

/*找出木块a在Wood中的列数*/
int get_j(int a) {
	int i = get_i(a);
	for (int j = 0; j < Wood[i].size(); j++) { if (Wood[i][j] == a) return j; }
	return -1;
}

/*将木块a上方的木块归位*/
void reset_above(int a) {
	int i = get_i(a);
	int j = get_j(a);
	for (int k = Wood[i].size() - 1; k > j; k--) {
		Wood[Wood[i][k]][0] = Wood[i][k];
		Wood[Wood[i][k]].pop_back();
		Wood[i].pop_back();
	}
}

/*操作pile a over b*/
void PV(int a, int b)
{
	int ib = get_i(b);
	int ia = get_i(a), ja = get_j(a);
	for (int j = ja; j < Wood[ia].size(); j++) Wood[ib].push_back(Wood[ia][j]); /*移到b上*/
	Wood[ia].resize(ja);
	if (Wood[ia].size() == 0) { Wood[ia].push_back(-1); Wood[ia].push_back(ib); }
}

int main()
{
	FILE* fin = fopen("input.txt", "r");
	FILE* fout = fopen("output.txt", "w");

	int n;
	fscanf(fin, "%d", &n);
	Wood.resize(n);

	/*初始化放木块的vector*/
	for (int i = 0; i < n; i++) Wood[i].push_back(i);
	char s1[10], s2[10];
	int a, b;

	/*录入操作并执行*/
	while (fscanf(fin, "%s %d %s %d", s1, &a, s2, &b) == 4)
	{
		if (get_i(a) == get_i(b)) continue; /*如果a,b在同一堆*/
		if (s1[0] == 'm') reset_above(a);
		if (s2[1] == 'n') reset_above(b);
		PV(a, b);
	}
	/*输出结果*/
	for (int i = 0; i < n; i++) {
		fprintf(fout, "%d:", i);
		if (Wood[i][0] != -1) {
			for (int j = 0; j < Wood[i].size(); j++) {
				if (j) fprintf(fout, " ");
				fprintf(fout, "%d", Wood[i][j]);
			}
		}
		fputc('\n', fout);
	}

	fclose(fin);
	fclose(fout);
	return 0;
}
```



## Andy's First Dictionary



### Q

样例输入
Adventures in Disneyland Two blondes were going to Disneyland when they came to a fork in the road. The sign read: "Disneyland Left.” So they went home.

样例输出
a
adventures
blondes
came
disneyland
fork
going
home
in
left
read
road
sign
so
the
they
to
two
went
were
when

### A3 

网上找的样例输入的双引号是中文("")的，在typora中和英文的引号("")一毛一样，浪费了半天时间排bug

```c++
#include <fstream>
#include<iostream>
#include<string>
#include<set>
#include<sstream>

int main()
{
	std::ifstream ifs;
	std::ofstream ofs;
	/*打开文件*/
	ifs.open("input.txt", std::ios::in);
	ofs.open("output.txt", std::ios::out | std::ios::trunc);


	std::string s,word;
	std::set<std::string> dict;
	
	while (ifs >> s){
		for (int i = 0; i < s.length(); i++) {
			if (isalpha(s[i])) s[i] = tolower(s[i]);
			else s[i] = ' '; /*将字符串s的字母换成小写，符号换为空格*/
		}
		/*将处理过的字符重新输入到words中*/
		std::stringstream ss(s); 
		while(ss >> word)dict.insert(word);
	}
	/*输出结果*/
	for (std::set<std::string>::iterator it = dict.begin(); it != dict.end(); it++)
	{
		ofs << *it << std::endl;
	}


	/*关闭文件*/
	ifs.close();
	ofs.close();
	return 0;
}
```

